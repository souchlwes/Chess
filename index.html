<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Brick Chess</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    body {
      background: radial-gradient(circle at center, #111 0%, #000 100%);
      font-family: 'Press Start 2P', monospace;
      color: #0f0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      position: relative;
      overflow: hidden;
    }
    .console { perspective: 1000px; }
    .shell {
      width: 400px;
      height: 660px;
      background: linear-gradient(to bottom, #2a5fb8, #1c3f7a);
      border-radius: 20px;
      box-shadow: 0 0 20px #0f0, inset 0 0 10px #000;
      padding: 20px;
      transform: rotateX(4deg);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      position: relative;
    }
    .logo {
      position: absolute;
      bottom: 10px;
      font-size: 12px;
      color: #000;
      text-shadow: 1px 1px #0f0;
    }
    .bolts {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 280px;
      font-size: 20px;
      color: #fff;
      text-shadow: 0 0 5px #0ff;
    }
    .screen {
      width: 320px;
      height: 320px;
      background: linear-gradient(to bottom, #0f0, #060);
      border: 4px inset #003300;
      box-shadow: inset 0 0 10px #003300, 0 0 10px #0f0;
      padding: 5px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      border-radius: 8px;
      animation: glow 2s infinite alternate;
    }
    @keyframes glow {
      from { box-shadow: inset 0 0 10px #003300, 0 0 5px #0f0; }
      to { box-shadow: inset 0 0 15px #003300, 0 0 15px #0f0; }
    }
    #board {
      width: 288px;
      height: 288px;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: 1px;
      background: #333;
      border: 2px solid #000;
    }
    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      cursor: pointer;
      user-select: none;
      text-shadow: 0 0 8px #000, 0 0 8px #000;
      color: #ffffff;
    }
    .square.black-piece { color: #000000; }
    .square.light { background: #fff8e1; }
    .square.dark { background: #6b4e31; }
    .square.selected { background: #ffeb3b !important; }
    .square.valid { background: #4caf50 !important; }
    .info {
      font-size: 10px;
      color: #000;
      background: #0f0;
      padding: 4px;
      border-top: 2px solid #003300;
      font-family: 'Press Start 2P', monospace;
    }
    #clock { margin-bottom: 5px; }
    #moves {
      max-height: 40px;
      overflow-x: auto;
      white-space: nowrap;
      font-size: 8px;
      background: #000;
      color: #0f0;
      padding: 2px;
      border: 1px solid #0f0;
      scrollbar-width: thin;
      scrollbar-color: #0f0 #000;
    }
    #moves::-webkit-scrollbar { height: 6px; }
    #moves::-webkit-scrollbar-thumb { background: #0f0; }
    #moves::-webkit-scrollbar-track { background: #000; }
    .controls {
      width: 320px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    button, select {
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      background: linear-gradient(to bottom, #444, #111);
      color: #0f0;
      border: 2px solid #0f0;
      padding: 6px;
      box-shadow: 0 4px #0a0;
      text-shadow: 0 1px #000;
      transition: all 0.2s ease;
      border-radius: 6px;
    }
    button:active, select:active {
      box-shadow: 0 2px #060;
      transform: translateY(2px);
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .computer-tab {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 150px;
      background: linear-gradient(to bottom, #2a5fb8, #1c3f7a);
      border: 4px solid #0f0;
      border-radius: 10px;
      box-shadow: 0 0 15px #0f0;
      color: #0f0;
      text-align: center;
      padding: 20px;
      z-index: 1000;
      font-size: 14px;
    }
    .computer-tab.active { display: flex; flex-direction: column; justify-content: center; }
    .computer-tab button {
      margin-top: 20px;
      padding: 8px 16px;
      font-size: 12px;
    }
    .error { color: red; position: absolute; top: 10px; left: 10px; }
    .promotion-menu {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2a5fb8;
      border: 2px solid #0f0;
      padding: 10px;
      z-index: 1001;
    }
    .promotion-menu.active { display: block; }
    .promotion-menu button { margin: 5px; }
  </style>
</head>
<body>
  <div class="console">
    <div class="shell">
      <div class="logo">CUBE GAME</div>
      <div class="bolts"><div class="bolt">⚡</div><div class="bolt">⚡</div></div>
      <div class="screen">
        <div id="board"></div>
        <div class="info">
          <div id="clock">⏱ 05:00</div>
          <div id="moves">No moves yet</div>
        </div>
      </div>
      <div class="controls">
        <button id="start">START</button>
        <button id="reset">RESET</button>
        <button id="ai-toggle">VS AI</button>
        <button id="multi-toggle">MULTI</button>
        <select id="mode-select">
          <option value="blitz">BLITZ</option>
          <option value="rapid">RAPID</option>
          <option value="classical">CLASSICAL</option>
        </select>
        <select id="ai-level">
          <option value="easy">AI: Easy</option>
          <option value="medium">AI: Medium</option>
          <option value="hard">AI: Hard</option>
        </select>
      </div>
    </div>
  </div>
  <div class="computer-tab" id="win-tab">
    <h2>Game Over!</h2>
    <p id="win-message"></p>
    <button id="close-tab">OK</button>
  </div>
  <div class="promotion-menu" id="promotion-menu">
    <button onclick="promote('Q')">Queen</button>
    <button onclick="promote('R')">Rook</button>
    <button onclick="promote('B')">Bishop</button>
    <button onclick="promote('N')">Knight</button>
  </div>

  <audio id="win-sound" src="The loser has to fall.mp3"></audio>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0-beta.2/chess.min.js"></script>
  <script>
    let game;
    let isAI = false;
    let aiLevel = 'easy';
    let currentPlayer = 'white';
    let clockTime = 300;
    let whiteTime = clockTime;
    let blackTime = clockTime;
    let timerInterval;
    let selectedSquare = null;
    const winSound = document.getElementById('win-sound');
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let position = null;
    let movesHistory = [];
    let castlingAvailable = { w: { k: true, q: true }, b: { k: true, q: true } };
    let lastMove = null;

    const pieceSymbols = {
      'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔',
      'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚'
    };

    function playBeep() {
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.frequency.value = 800;
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      } catch (e) { console.log('Beep failed:', e); }
    }

    function isValidMove(from, to) {
      if (game && typeof game.move === 'function') {
        const move = game.move({ from, to, promotion: 'q' });
        if (move) {
          game.undo();
          return true;
        }
        return false;
      }
      const piece = position[from];
      if (!piece) return false;
      const isWhite = piece === piece.toUpperCase();
      if ((isWhite && currentPlayer !== 'white') || (!isWhite && currentPlayer !== 'black')) return false;
      const fromRow = 8 - parseInt(from[1]);
      const toRow = 8 - parseInt(to[1]);
      const fromCol = from.charCodeAt(0) - 97;
      const toCol = to.charCodeAt(0) - 97;
      const colDiff = Math.abs(toCol - fromCol);
      const rowDiff = toRow - fromRow;
      const dir = isWhite ? -1 : 1;
      const target = position[to];

      if (piece.toLowerCase() === 'p') {
        if (colDiff === 0 && !target && rowDiff === dir) return true;
        if (colDiff === 0 && !target && ((isWhite && fromRow === 6 && toRow === 4 && !position[from[0] + '7'] && !position[from[0] + '6']) || (!isWhite && fromRow === 1 && toRow === 3 && !position[from[0] + '2'] && !position[from[0] + '3']))) return true;
        if (colDiff === 1 && rowDiff === dir && target && ((isWhite && target === target.toLowerCase()) || (!isWhite && target === target.toUpperCase()))) return true;
        if (colDiff === 1 && rowDiff === dir && !target && lastMove && lastMove.from[1] === (isWhite ? '2' : '7') && lastMove.to[1] === (isWhite ? '4' : '5') && Math.abs(lastMove.to.charCodeAt(0) - to.charCodeAt(0)) === 1) {
          return position[to[0] + (isWhite ? '4' : '5')] === (isWhite ? 'p' : 'P');
        }
        return false;
      } else if (piece.toLowerCase() === 'n') {
        const knightMoves = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
        return knightMoves.some(([r, c]) => rowDiff === r && colDiff === Math.abs(c));
      } else if (piece.toLowerCase() === 'k') {
        if (colDiff <= 1 && rowDiff <= 1) return true;
        if (colDiff === 2 && rowDiff === 0 && !target) {
          const kingSide = toCol === 6;
          const rookFrom = kingSide ? 'h' + (isWhite ? '1' : '8') : 'a' + (isWhite ? '1' : '8');
          const rookTo = kingSide ? 'f' + (isWhite ? '1' : '8') : 'd' + (isWhite ? '1' : '8');
          return castlingAvailable[isWhite ? 'w' : 'b'][kingSide ? 'k' : 'q'] &&
                 position[rookFrom] === (isWhite ? 'R' : 'r') &&
                 !Object.keys(position).some(s => {
                   const r = 8 - parseInt(s[1]);
                   const c = s.charCodeAt(0) - 97;
                   return position[s] && r === (isWhite ? 1 : 8) && c >= (kingSide ? 5 : 3) && c <= (kingSide ? 6 : 4);
                 });
        }
        return false;
      } else if (piece.toLowerCase() === 'q' || piece.toLowerCase() === 'r') {
        return colDiff === 0 || rowDiff === 0;
      } else if (piece.toLowerCase() === 'b') {
        return colDiff === rowDiff;
      }
      return !target || (isWhite && target === target.toLowerCase()) || (!isWhite && target === target.toUpperCase());
    }

    function createBoard() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          square.classList.add('square');
          square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
          square.dataset.row = row;
          square.dataset.col = col;
          square.addEventListener('click', () => handleSquareClick(row, col));
          boardEl.appendChild(square);
        }
      }
      updateBoard();
    }

    function handleSquareClick(row, col) {
      const square = String.fromCharCode(97 + col) + (8 - row);
      const piece = game ? game.get(square) : position[square];

      if (selectedSquare) {
        if (isValidMove(selectedSquare, square)) {
          const fromRow = 8 - parseInt(selectedSquare[1]);
          const toRow = 8 - parseInt(square[1]);
          const fromCol = selectedSquare.charCodeAt(0) - 97;
          const toCol = square.charCodeAt(0) - 97;
          const colDiff = Math.abs(toCol - fromCol);
          const rowDiff = toRow - fromRow;
          const isWhite = game ? game.get(selectedSquare).color === 'w' : position[selectedSquare] === position[selectedSquare].toUpperCase();

          if (game) {
            const move = game.move({ from: selectedSquare, to: square });
            if (move) {
              movesHistory.push(move.san);
              lastMove = { from: selectedSquare, to: square };
              if (move.flags.includes('k')) castlingAvailable[move.color === 'w' ? 'w' : 'b'].k = false;
              if (move.flags.includes('q')) castlingAvailable[move.color === 'w' ? 'w' : 'b'].q = false;
            }
          } else {
            position[square] = position[selectedSquare];
            delete position[selectedSquare];
            if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
              document.getElementById('promotion-menu').classList.add('active');
              selectedSquare = square;
              return;
            }
            if (piece.toLowerCase() === 'p' && colDiff === 1 && rowDiff === (isWhite ? -2 : 2) && !position[square]) {
              delete position[square[0] + (isWhite ? '5' : '4')];
            }
            if (piece.toLowerCase() === 'k' && colDiff === 2) {
              const kingSide = toCol === 6;
              const rookFrom = kingSide ? 'h' + (isWhite ? '1' : '8') : 'a' + (isWhite ? '1' : '8');
              const rookTo = kingSide ? 'f' + (isWhite ? '1' : '8') : 'd' + (isWhite ? '1' : '8');
              position[rookTo] = position[rookFrom];
              delete position[rookFrom];
              castlingAvailable[isWhite ? 'w' : 'b'][kingSide ? 'k' : 'q'] = false;
            }
            movesHistory.push(`${selectedSquare}-${square}`);
            lastMove = { from: selectedSquare, to: square };
          }
          selectedSquare = null;
          updateBoard();
          updateTicker();
          switchTurn();
          checkGameOver();
        } else {
          selectedSquare = null;
          updateBoard();
        }
      } else {
        if (piece && ((game && piece.color === currentPlayer[0]) || (!game && ((piece === piece.toUpperCase() && currentPlayer === 'white') || (piece === piece.toLowerCase() && currentPlayer === 'black'))))) {
          selectedSquare = square;
          updateBoard();
        }
      }
    }

    function evaluateMove(move) {
      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      let score = 0;
      if (move.captured) score += pieceValues[move.captured.toLowerCase()];
      if (move.flags && move.flags.includes('c')) score += 5;
      if (move.san && move.san.includes('+')) score += 2;
      return score + Math.random() * 0.1;
    }

    function makeAIMove() {
      if (!isAI || currentPlayer !== 'black') return;
      if (game) {
        const moves = game.moves({ verbose: true });
        if (moves.length) {
          let move;
          if (aiLevel === 'easy') {
            move = moves[Math.floor(Math.random() * moves.length)];
          } else if (aiLevel === 'medium') {
            const scored = moves.map(m => ({ move: m, score: evaluateMove(m) }));
            scored.sort((a, b) => b.score - a.score);
            const topMoves = scored.slice(0, Math.ceil(scored.length / 2));
            move = topMoves[Math.floor(Math.random() * topMoves.length)].move;
          } else {
            const scored = moves.map(m => ({ move: m, score: evaluateMove(m) }));
            move = scored.reduce((best, curr) => curr.score > best.score ? curr : best, scored[0]).move;
          }
          game.move(move);
          movesHistory.push(move.san);
          updateBoard();
          updateTicker();
          switchTurn();
          checkGameOver();
        }
      } else {
        const pieces = Object.keys(position).filter(s => position[s] && ((position[s] === position[s].toLowerCase() && currentPlayer === 'black') || (position[s] === position[s].toUpperCase() && currentPlayer === 'white')));
        if (pieces.length) {
          const from = pieces[Math.floor(Math.random() * pieces.length)];
          const fromRow = 8 - parseInt(from[1]);
          const fromCol = from.charCodeAt(0) - 97;
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              const to = String.fromCharCode(97 + col) + (8 - row);
              if (isValidMove(from, to)) {
                handleSquareClick(row, col); // Reuse move logic
                return;
              }
            }
          }
        }
      }
    }

    function switchTurn() {
      currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
      if (isAI && currentPlayer === 'black') setTimeout(makeAIMove, 500);
    }

    function updateBoard() {
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const squareEl = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
          const square = String.fromCharCode(97 + col) + (8 - row);
          const piece = game ? game.get(square) : position[square];
          squareEl.textContent = piece ? (game ? pieceSymbols[piece.type.toUpperCase() + (piece.color === 'w' ? '' : piece.type.toLowerCase())] : pieceSymbols[piece]) || '' : '';
          squareEl.classList.remove('selected', 'valid', 'black-piece');
          if (piece && ((game && piece.color === 'b') || (!game && piece === piece.toLowerCase()))) squareEl.classList.add('black-piece');
          if (selectedSquare === square) {
            squareEl.classList.add('selected');
          } else if (selectedSquare) {
            const moves = game ? game.moves({ square: selectedSquare, verbose: true }) : [];
            if (moves.some(m => m.to === square) || (!game && isValidMove(selectedSquare, square))) {
              squareEl.classList.add('valid');
            }
          }
        }
      }
    }

    function updateTicker() {
      document.getElementById('moves').innerText = movesHistory.length ? movesHistory.join(' • ') : 'No moves yet';
    }

    function startClock() {
      stopClock();
      timerInterval = setInterval(() => {
        if (currentPlayer === 'white') whiteTime--;
        else blackTime--;
        updateClock();
        if (whiteTime <= 0 || blackTime <= 0) {
          showWinMessage(whiteTime <= 0 ? 'Black' : 'White', 'Time\'s up!');
          stopClock();
        }
      }, 1000);
    }

    function stopClock() {
      clearInterval(timerInterval);
    }

    function updateClock() {
      const format = (t) => `${Math.floor(t / 60)}:${String(t % 60).padStart(2, '0')}`;
      document.getElementById('clock').innerText = `W ${format(whiteTime)} | B ${format(blackTime)}`;
    }

    function resetGame() {
      if (game) game.reset();
      else {
        position = {
          a8: 'r', b8: 'n', c8: 'b', d8: 'q', e8: 'k', f8: 'b', g8: 'n', h8: 'r',
          a7: 'p', b7: 'p', c7: 'p', d7: 'p', e7: 'p', f7: 'p', g7: 'p', h7: 'p',
          a2: 'P', b2: 'P', c2: 'P', d2: 'P', e2: 'P', f2: 'P', g2: 'P', h2: 'P',
          a1: 'R', b1: 'N', c1: 'B', d1: 'Q', e1: 'K', f1: 'B', g1: 'N', h1: 'R'
        };
        castlingAvailable = { w: { k: true, q: true }, b: { k: true, q: true } };
      }
      whiteTime = clockTime;
      blackTime = clockTime;
      currentPlayer = 'white';
      selectedSquare = null;
      isAI = false;
      movesHistory = [];
      lastMove = null;
      updateBoard();
      updateTicker();
      updateClock();
      stopClock();
      document.getElementById('ai-toggle').disabled = false;
      document.getElementById('multi-toggle').disabled = false;
    }

    function setClockMode(mode) {
      if (mode === 'blitz') clockTime = 300;
      else if (mode === 'rapid') clockTime = 900;
      else if (mode === 'classical') clockTime = 1800;
      resetGame();
    }

    function showWinMessage(winner, reason) {
      console.log('Showing win message:', winner, reason);
      const winTab = document.getElementById('win-tab');
      const winMessage = document.getElementById('win-message');
      if (!winTab || !winMessage) {
        console.error('Win tab elements not found');
        return;
      }
      winMessage.textContent = `${reason} ${winner} wins!`;
      winTab.classList.add('active');
      try {
        winSound.play().catch(e => {
          console.log('MP3 play failed:', e);
          playBeep();
        });
      } catch (e) { console.log('Audio error:', e); }
      stopClock();
    }

    function checkGameOver() {
      if (game && game.game_over()) {
        const winner = game.in_checkmate() ? (currentPlayer === 'white' ? 'Black' : 'White') : game.in_draw() ? 'Draw' : '';
        if (winner) showWinMessage(winner, 'Game Over!');
      } else if (!game) {
        const whiteKing = Object.keys(position).some(s => position[s] === 'K');
        const blackKing = Object.keys(position).some(s => position[s] === 'k');
        if (!whiteKing || !blackKing) {
          const winner = !whiteKing ? 'Black' : 'White';
          showWinMessage(winner, 'Game Over!');
        } else {
          const kingSquare = Object.keys(position).find(s => position[s] === (currentPlayer === 'white' ? 'k' : 'K'));
          if (kingSquare) {
            const kingRow = 8 - parseInt(kingSquare[1]);
            const kingCol = kingSquare.charCodeAt(0) - 97;
            const isCheck = Object.keys(position).some(s => {
              const p = position[s];
              const r = 8 - parseInt(s[1]);
              const c = s.charCodeAt(0) - 97;
              if ((currentPlayer === 'white' && p === p.toUpperCase()) || (currentPlayer === 'black' && p === p.toLowerCase())) return false;
              const diffRow = Math.abs(r - kingRow);
              const diffCol = Math.abs(c - kingCol);
              if (p.toLowerCase() === 'q' || p.toLowerCase() === 'r') return diffRow === 0 || diffCol === 0;
              if (p.toLowerCase() === 'b') return diffRow === diffCol;
              if (p.toLowerCase() === 'p') return diffRow === 1 && diffCol === 1 && ((currentPlayer === 'white' && r === kingRow - 1) || (currentPlayer === 'black' && r === kingRow + 1));
              if (p.toLowerCase() === 'n') return (diffRow === 2 && diffCol === 1) || (diffRow === 1 && diffCol === 2);
              return false;
            });
            if (isCheck) {
              const legalMoves = Object.keys(position).filter(s => position[s] === (currentPlayer === 'white' ? 'k' : 'K')).some(k => {
                for (let r = -1; r <= 1; r++) for (let c = -1; c <= 1; c++) {
                  const newRow = kingRow + r;
                  const newCol = kingCol + c;
                  if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const newSquare = String.fromCharCode(97 + newCol) + (8 - newRow);
                    if (!position[newSquare] || (position[newSquare] !== position[newSquare].toUpperCase() && currentPlayer === 'white') || (position[newSquare] !== position[newSquare].toLowerCase() && currentPlayer === 'black')) {
                      const temp = position[k];
                      position[newSquare] = temp;
                      delete position[k];
                      const stillCheck = Object.keys(position).some(s => {
                        const p = position[s];
                        const r2 = 8 - parseInt(s[1]);
                        const c2 = s.charCodeAt(0) - 97;
                        if ((currentPlayer === 'white' && p === p.toUpperCase()) || (currentPlayer === 'black' && p === p.toLowerCase())) return false;
                        const diffRow2 = Math.abs(r2 - newRow);
                        const diffCol2 = Math.abs(c2 - newCol);
                        if (p.toLowerCase() === 'q' || p.toLowerCase() === 'r') return diffRow2 === 0 || diffCol2 === 0;
                        if (p.toLowerCase() === 'b') return diffRow2 === diffCol2;
                        if (p.toLowerCase() === 'p') return diffRow2 === 1 && diffCol2 === 1;
                        if (p.toLowerCase() === 'n') return (diffRow2 === 2 && diffCol2 === 1) || (diffRow2 === 1 && diffCol2 === 2);
                        return false;
                      });
                      position[k] = temp;
                      delete position[newSquare];
                      if (!stillCheck) return true;
                    }
                  }
                }
                return false;
              });
              if (!legalMoves) showWinMessage(currentPlayer === 'white' ? 'Black' : 'White', 'Checkmate!');
            }
          }
        }
      }
    }

    function promote(piece) {
      const isWhite = game ? game.get(selectedSquare).color === 'w' : position[selectedSquare] === position[selectedSquare].toUpperCase();
      if (game) {
        game.move({ from: selectedSquare, to: selectedSquare, promotion: piece.toLowerCase() });
      } else {
        position[selectedSquare] = isWhite ? piece : piece.toLowerCase();
      }
      document.getElementById('promotion-menu').classList.remove('active');
      selectedSquare = null;
      updateBoard();
      updateTicker();
      switchTurn();
      checkGameOver();
    }

    document.getElementById('start').onclick = () => {
      resetGame();
      startClock();
    };
    document.getElementById('reset').onclick = resetGame;
    document.getElementById('ai-toggle').onclick = () => {
      isAI = true;
      resetGame();
      document.getElementById('multi-toggle').disabled = true;
      document.getElementById('ai-toggle').disabled = true;
    };
    document.getElementById('multi-toggle').onclick = () => {
      isAI = false;
      resetGame();
      document.getElementById('ai-toggle').disabled = true;
      document.getElementById('multi-toggle').disabled = true;
    };
    document.getElementById('mode-select').onchange = (e) => setClockMode(e.target.value);
    document.getElementById('ai-level').onchange = (e) => {
      aiLevel = e.target.value;
      resetGame();
    };
    document.getElementById('close-tab').onclick = () => {
      document.getElementById('win-tab').classList.remove('active');
    };

    window.addEventListener('load', () => {
      winSound.load();
      if (typeof Chess === 'undefined') {
        document.body.innerHTML += '<div class="error">Warning: Chess.js failed to load. Using fallback engine.</div>';
        position = {
          a8: 'r', b8: 'n', c8: 'b', d8: 'q', e8: 'k', f8: 'b', g8: 'n', h8: 'r',
          a7: 'p', b7: 'p', c7: 'p', d7: 'p', e7: 'p', f7: 'p', g7: 'p', h7: 'p',
          a2: 'P', b2: 'P', c2: 'P', d2: 'P', e2: 'P', f2: 'P', g2: 'P', h2: 'P',
          a1: 'R', b1: 'N', c1: 'B', d1: 'Q', e1: 'K', f1: 'B', g1: 'N', h1: 'R'
        };
      } else {
        game = new Chess();
      }
      createBoard();
      resetGame();
    });
  </script>
</body>
</html>